{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = createAnimatedComponent;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _reactNative = require(\"react-native\");\n\nvar _ReanimatedEventEmitter = _interopRequireDefault(require(\"./ReanimatedEventEmitter\"));\n\nvar _AnimatedEvent = _interopRequireDefault(require(\"./core/AnimatedEvent\"));\n\nvar _AnimatedNode = _interopRequireDefault(require(\"./core/AnimatedNode\"));\n\nvar _AnimatedValue = _interopRequireDefault(require(\"./core/AnimatedValue\"));\n\nvar _AnimatedProps = require(\"./core/AnimatedProps\");\n\nvar _invariant = _interopRequireDefault(require(\"fbjs/lib/invariant\"));\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar NODE_MAPPING = new Map();\n\nfunction listener(data) {\n  var component = NODE_MAPPING.get(data.viewTag);\n  component && component._updateFromNative(data.props);\n}\n\nfunction dummyListener() {}\n\nfunction createAnimatedComponent(Component) {\n  (0, _invariant.default)(typeof Component !== 'function' || Component.prototype && Component.prototype.isReactComponent, '`createAnimatedComponent` does not support stateless functional components; ' + 'use a class component instead.');\n\n  var AnimatedComponent = function (_React$Component) {\n    (0, _inherits2.default)(AnimatedComponent, _React$Component);\n\n    var _super = _createSuper(AnimatedComponent);\n\n    function AnimatedComponent(props) {\n      var _this;\n\n      (0, _classCallCheck2.default)(this, AnimatedComponent);\n      _this = _super.call(this, props);\n\n      _defineProperty((0, _assertThisInitialized2.default)(_this), \"_invokeAnimatedPropsCallbackOnMount\", false);\n\n      _defineProperty((0, _assertThisInitialized2.default)(_this), \"_animatedPropsCallback\", function () {\n        if (_this._component == null) {\n          _this._invokeAnimatedPropsCallbackOnMount = true;\n        } else if (typeof _this._component.setNativeProps !== 'function') {\n          _this.forceUpdate();\n        } else {\n          _this._component.setNativeProps(_this._propsAnimated.__getValue());\n        }\n      });\n\n      _defineProperty((0, _assertThisInitialized2.default)(_this), \"_setComponentRef\", function (c) {\n        if (c !== _this._component) {\n          _this._component = c;\n        }\n      });\n\n      _this._attachProps(_this.props);\n\n      return _this;\n    }\n\n    (0, _createClass2.default)(AnimatedComponent, [{\n      key: \"componentWillUnmount\",\n      value: function componentWillUnmount() {\n        this._detachPropUpdater();\n\n        this._propsAnimated && this._propsAnimated.__detach();\n\n        this._detachNativeEvents();\n      }\n    }, {\n      key: \"setNativeProps\",\n      value: function setNativeProps(props) {\n        this._component.setNativeProps(props);\n      }\n    }, {\n      key: \"componentDidMount\",\n      value: function componentDidMount() {\n        if (this._invokeAnimatedPropsCallbackOnMount) {\n          this._invokeAnimatedPropsCallbackOnMount = false;\n\n          this._animatedPropsCallback();\n        }\n\n        this._propsAnimated.setNativeView(this._component);\n\n        this._attachNativeEvents();\n\n        this._attachPropUpdater();\n      }\n    }, {\n      key: \"_getEventViewRef\",\n      value: function _getEventViewRef() {\n        return this._component.getScrollableNode ? this._component.getScrollableNode() : this._component;\n      }\n    }, {\n      key: \"_attachNativeEvents\",\n      value: function _attachNativeEvents() {\n        var node = this._getEventViewRef();\n\n        for (var key in this.props) {\n          var prop = this.props[key];\n\n          if (prop instanceof _AnimatedEvent.default) {\n            prop.attachEvent(node, key);\n          }\n        }\n      }\n    }, {\n      key: \"_detachNativeEvents\",\n      value: function _detachNativeEvents() {\n        var node = this._getEventViewRef();\n\n        for (var key in this.props) {\n          var prop = this.props[key];\n\n          if (prop instanceof _AnimatedEvent.default) {\n            prop.detachEvent(node, key);\n          }\n        }\n      }\n    }, {\n      key: \"_reattachNativeEvents\",\n      value: function _reattachNativeEvents(prevProps) {\n        var node = this._getEventViewRef();\n\n        var attached = new Set();\n        var nextEvts = new Set();\n\n        for (var key in this.props) {\n          var prop = this.props[key];\n\n          if (prop instanceof _AnimatedEvent.default) {\n            nextEvts.add(prop.__nodeID);\n          }\n        }\n\n        for (var _key in prevProps) {\n          var _prop = this.props[_key];\n\n          if (_prop instanceof _AnimatedEvent.default) {\n            if (!nextEvts.has(_prop.__nodeID)) {\n              _prop.detachEvent(node, _key);\n            } else {\n              attached.add(_prop.__nodeID);\n            }\n          }\n        }\n\n        for (var _key2 in this.props) {\n          var _prop2 = this.props[_key2];\n\n          if (_prop2 instanceof _AnimatedEvent.default && !attached.has(_prop2.__nodeID)) {\n            _prop2.attachEvent(node, _key2);\n          }\n        }\n      }\n    }, {\n      key: \"_attachProps\",\n      value: function _attachProps(nextProps) {\n        var oldPropsAnimated = this._propsAnimated;\n        this._propsAnimated = (0, _AnimatedProps.createOrReusePropsNode)(nextProps, this._animatedPropsCallback, oldPropsAnimated);\n\n        if (oldPropsAnimated !== this._propsAnimated) {\n          oldPropsAnimated && oldPropsAnimated.__detach();\n        }\n      }\n    }, {\n      key: \"_updateFromNative\",\n      value: function _updateFromNative(props) {\n        this._component.setNativeProps(props);\n      }\n    }, {\n      key: \"_attachPropUpdater\",\n      value: function _attachPropUpdater() {\n        var viewTag = (0, _reactNative.findNodeHandle)(this);\n        NODE_MAPPING.set(viewTag, this);\n\n        if (NODE_MAPPING.size === 1) {\n          _ReanimatedEventEmitter.default.addListener('onReanimatedPropsChange', listener);\n        }\n      }\n    }, {\n      key: \"_detachPropUpdater\",\n      value: function _detachPropUpdater() {\n        var viewTag = (0, _reactNative.findNodeHandle)(this);\n        NODE_MAPPING.delete(viewTag);\n\n        if (NODE_MAPPING.size === 0) {\n          _ReanimatedEventEmitter.default.removeAllListeners('onReanimatedPropsChange');\n        }\n      }\n    }, {\n      key: \"componentDidUpdate\",\n      value: function componentDidUpdate(prevProps) {\n        this._attachProps(this.props);\n\n        this._reattachNativeEvents(prevProps);\n\n        this._propsAnimated.setNativeView(this._component);\n      }\n    }, {\n      key: \"_filterNonAnimatedStyle\",\n      value: function _filterNonAnimatedStyle(inputStyle) {\n        var style = {};\n\n        for (var key in inputStyle) {\n          var value = inputStyle[key];\n\n          if (key !== 'transform') {\n            if (value instanceof _AnimatedValue.default) {\n              style[key] = value._startingValue;\n            } else if (!(value instanceof _AnimatedNode.default)) {\n              style[key] = value;\n            }\n          }\n        }\n\n        return style;\n      }\n    }, {\n      key: \"_filterNonAnimatedProps\",\n      value: function _filterNonAnimatedProps(inputProps) {\n        var props = {};\n\n        for (var key in inputProps) {\n          var value = inputProps[key];\n\n          if (key === 'style') {\n            props[key] = this._filterNonAnimatedStyle(_reactNative.StyleSheet.flatten(value));\n          } else if (value instanceof _AnimatedEvent.default) {\n            props[key] = dummyListener;\n          } else if (value instanceof _AnimatedValue.default) {\n            props[key] = value._startingValue;\n          } else if (!(value instanceof _AnimatedNode.default)) {\n            props[key] = value;\n          }\n        }\n\n        return props;\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        var props = this._filterNonAnimatedProps(this.props);\n\n        var platformProps = _reactNative.Platform.select({\n          web: {},\n          default: {\n            collapsable: false\n          }\n        });\n\n        return _react.default.createElement(Component, _extends({}, props, {\n          ref: this._setComponentRef\n        }, platformProps));\n      }\n    }, {\n      key: \"getNode\",\n      value: function getNode() {\n        return this._component;\n      }\n    }]);\n    return AnimatedComponent;\n  }(_react.default.Component);\n\n  AnimatedComponent.displayName = \"AnimatedComponent(\".concat(Component.displayName || Component.name || 'Component', \")\");\n  return AnimatedComponent;\n}","map":{"version":3,"sources":["createAnimatedComponent.js"],"names":["NODE_MAPPING","component","data","invariant","Component","React","constructor","node","prop","attached","nextEvts","oldPropsAnimated","createOrReusePropsNode","viewTag","findNodeHandle","ReanimatedEventEmitter","c","style","value","inputStyle","key","props","inputProps","StyleSheet","platformProps","web","default","collapsable","_setComponentRef","AnimatedComponent"],"mappings":"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","sourcesContent":["import React from 'react';\nimport { findNodeHandle, Platform, StyleSheet } from 'react-native';\nimport ReanimatedEventEmitter from './ReanimatedEventEmitter';\n\nimport AnimatedEvent from './core/AnimatedEvent';\nimport AnimatedNode from './core/AnimatedNode';\nimport AnimatedValue from './core/AnimatedValue';\nimport { createOrReusePropsNode } from './core/AnimatedProps';\n\nimport invariant from 'fbjs/lib/invariant';\n\nconst NODE_MAPPING = new Map();\n\nfunction listener(data) {\n  const component = NODE_MAPPING.get(data.viewTag);\n  component && component._updateFromNative(data.props);\n}\n\nfunction dummyListener() {\n  // empty listener we use to assign to listener properties for which animated\n  // event is used.\n}\n\nexport default function createAnimatedComponent(Component) {\n  invariant(\n    typeof Component !== 'function' ||\n      (Component.prototype && Component.prototype.isReactComponent),\n    '`createAnimatedComponent` does not support stateless functional components; ' +\n      'use a class component instead.'\n  );\n\n  class AnimatedComponent extends React.Component {\n    _invokeAnimatedPropsCallbackOnMount = false;\n\n    constructor(props) {\n      super(props);\n      this._attachProps(this.props);\n    }\n\n    componentWillUnmount() {\n      this._detachPropUpdater();\n      this._propsAnimated && this._propsAnimated.__detach();\n      this._detachNativeEvents();\n    }\n\n    setNativeProps(props) {\n      this._component.setNativeProps(props);\n    }\n\n    componentDidMount() {\n      if (this._invokeAnimatedPropsCallbackOnMount) {\n        this._invokeAnimatedPropsCallbackOnMount = false;\n        this._animatedPropsCallback();\n      }\n\n      this._propsAnimated.setNativeView(this._component);\n      this._attachNativeEvents();\n      this._attachPropUpdater();\n    }\n\n    _getEventViewRef() {\n      // Make sure to get the scrollable node for components that implement\n      // `ScrollResponder.Mixin`.\n      return this._component.getScrollableNode\n        ? this._component.getScrollableNode()\n        : this._component;\n    }\n\n    _attachNativeEvents() {\n      const node = this._getEventViewRef();\n\n      for (const key in this.props) {\n        const prop = this.props[key];\n        if (prop instanceof AnimatedEvent) {\n          prop.attachEvent(node, key);\n        }\n      }\n    }\n\n    _detachNativeEvents() {\n      const node = this._getEventViewRef();\n\n      for (const key in this.props) {\n        const prop = this.props[key];\n        if (prop instanceof AnimatedEvent) {\n          prop.detachEvent(node, key);\n        }\n      }\n    }\n\n    _reattachNativeEvents(prevProps) {\n      const node = this._getEventViewRef();\n      const attached = new Set();\n      const nextEvts = new Set();\n      for (const key in this.props) {\n        const prop = this.props[key];\n        if (prop instanceof AnimatedEvent) {\n          nextEvts.add(prop.__nodeID);\n        }\n      }\n      for (const key in prevProps) {\n        const prop = this.props[key];\n        if (prop instanceof AnimatedEvent) {\n          if (!nextEvts.has(prop.__nodeID)) {\n            // event was in prev props but not in current props, we detach\n            prop.detachEvent(node, key);\n          } else {\n            // event was in prev and is still in current props\n            attached.add(prop.__nodeID);\n          }\n        }\n      }\n      for (const key in this.props) {\n        const prop = this.props[key];\n        if (prop instanceof AnimatedEvent && !attached.has(prop.__nodeID)) {\n          // not yet attached\n          prop.attachEvent(node, key);\n        }\n      }\n    }\n\n    // The system is best designed when setNativeProps is implemented. It is\n    // able to avoid re-rendering and directly set the attributes that changed.\n    // However, setNativeProps can only be implemented on native components\n    // If you want to animate a composite component, you need to re-render it.\n    // In this case, we have a fallback that uses forceUpdate.\n    _animatedPropsCallback = () => {\n      if (this._component == null) {\n        // AnimatedProps is created in will-mount because it's used in render.\n        // But this callback may be invoked before mount in async mode,\n        // In which case we should defer the setNativeProps() call.\n        // React may throw away uncommitted work in async mode,\n        // So a deferred call won't always be invoked.\n        this._invokeAnimatedPropsCallbackOnMount = true;\n      } else if (typeof this._component.setNativeProps !== 'function') {\n        this.forceUpdate();\n      } else {\n        this._component.setNativeProps(this._propsAnimated.__getValue());\n      }\n    };\n\n    _attachProps(nextProps) {\n      const oldPropsAnimated = this._propsAnimated;\n\n      this._propsAnimated = createOrReusePropsNode(\n        nextProps,\n        this._animatedPropsCallback,\n        oldPropsAnimated\n      );\n      // If prop node has been reused we don't need to call into \"__detach\"\n      if (oldPropsAnimated !== this._propsAnimated) {\n        // When you call detach, it removes the element from the parent list\n        // of children. If it goes to 0, then the parent also detaches itself\n        // and so on.\n        // An optimization is to attach the new elements and THEN detach the old\n        // ones instead of detaching and THEN attaching.\n        // This way the intermediate state isn't to go to 0 and trigger\n        // this expensive recursive detaching to then re-attach everything on\n        // the very next operation.\n        oldPropsAnimated && oldPropsAnimated.__detach();\n      }\n    }\n\n    _updateFromNative(props) {\n      this._component.setNativeProps(props);\n    }\n\n    _attachPropUpdater() {\n      const viewTag = findNodeHandle(this);\n      NODE_MAPPING.set(viewTag, this);\n      if (NODE_MAPPING.size === 1) {\n        ReanimatedEventEmitter.addListener('onReanimatedPropsChange', listener);\n      }\n    }\n\n    _detachPropUpdater() {\n      const viewTag = findNodeHandle(this);\n      NODE_MAPPING.delete(viewTag);\n      if (NODE_MAPPING.size === 0) {\n        ReanimatedEventEmitter.removeAllListeners('onReanimatedPropsChange');\n      }\n    }\n\n    componentDidUpdate(prevProps) {\n      this._attachProps(this.props);\n      this._reattachNativeEvents(prevProps);\n\n      this._propsAnimated.setNativeView(this._component);\n    }\n\n    _setComponentRef = c => {\n      if (c !== this._component) {\n        this._component = c;\n      }\n    };\n\n    _filterNonAnimatedStyle(inputStyle) {\n      const style = {};\n      for (const key in inputStyle) {\n        const value = inputStyle[key];\n        if (key !== 'transform') {\n          if (value instanceof AnimatedValue) {\n            style[key] = value._startingValue;\n          } else if (!(value instanceof AnimatedNode)) {\n            style[key] = value;\n          }\n        }\n      }\n      return style;\n    }\n\n    _filterNonAnimatedProps(inputProps) {\n      const props = {};\n      for (const key in inputProps) {\n        const value = inputProps[key];\n        if (key === 'style') {\n          props[key] = this._filterNonAnimatedStyle(StyleSheet.flatten(value));\n        } else if (value instanceof AnimatedEvent) {\n          // we cannot filter out event listeners completely as some components\n          // rely on having a callback registered in order to generate events\n          // alltogether. Therefore we provide a dummy callback here to allow\n          // native event dispatcher to hijack events.\n          props[key] = dummyListener;\n        } else if (value instanceof AnimatedValue) {\n          props[key] = value._startingValue;\n        } else if (!(value instanceof AnimatedNode)) {\n          props[key] = value;\n        }\n      }\n      return props;\n    }\n\n    render() {\n      const props = this._filterNonAnimatedProps(this.props);\n      const platformProps = Platform.select({\n        web: {},\n        default: { collapsable: false },\n      });\n      return (\n        <Component {...props} ref={this._setComponentRef} {...platformProps} />\n      );\n    }\n\n    // A third party library can use getNode()\n    // to get the node reference of the decorated component\n    getNode() {\n      return this._component;\n    }\n  }\n\n  AnimatedComponent.displayName = `AnimatedComponent(${Component.displayName ||\n    Component.name ||\n    'Component'})`;\n\n  return AnimatedComponent;\n}\n"]},"metadata":{},"sourceType":"script"}